package main

import (
	"bytes"
	"flag"
	"fmt"
	"html/template"
	"log"
	"net"
	"os"
	"os/exec"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"time"

	"{{ .ModuleName }}/internal/routes"
{{ if eq .Framework "gin" }}
	"github.com/gin-gonic/gin"
{{ else if eq .Framework "echo" }}
	"github.com/labstack/echo/v4"
	"net/http"
{{ else if eq .Framework "fiber" }}
	"github.com/gofiber/fiber/v2"
{{ else if eq .Framework "nethttp" }}
	"net/http"
{{ end }}
)

const serverPort = 8080
const (
	defaultProjectName = "{{ .ProjectName }}"
	defaultFramework   = "{{ .Framework }}"
	defaultCLIVersion  = "{{ .CLIVersion }}"
)

type runtimeOptions struct {
	Open bool
}

type PageData struct {
	ProjectName string
	Framework   string
	CLIVersion  string
}

func parseRuntimeOptions() runtimeOptions {
	open := flag.Bool("open", false, "Open browser after server starts")
	flag.Parse()
	return runtimeOptions{Open: *open}
}

func openBrowser(targetURL string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "linux":
		cmd = exec.Command("xdg-open", targetURL)
	case "darwin":
		cmd = exec.Command("open", targetURL)
	case "windows":
		cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", targetURL)
	default:
		return fmt.Errorf("unsupported platform %q", runtime.GOOS)
	}

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("open browser command failed: %w", err)
	}
	return nil
}

func openBrowserIfRequested(open bool, port int) {
	if !open {
		return
	}

	targetURL := fmt.Sprintf("http://localhost:%d", port)
	go func() {
		if err := openBrowser(targetURL); err != nil {
			log.Printf("browser auto-open skipped: %v", err)
		}
	}()
}

func resolveTemplatePath() string {
	raw := strings.TrimSpace(os.Getenv("INDEX_TEMPLATE_PATH"))
	if raw == "" {
		return filepath.Join("templates", "index.html")
	}
	return raw
}

func resolveImagePath() string {
	raw := strings.TrimSpace(os.Getenv("INDEX_IMAGE_PATH"))
	if raw == "" {
		return filepath.Join("templates", "lalibela2.webp")
	}
	return raw
}

func renderHomePage(templatePath string, data PageData) ([]byte, error) {
	tmpl, err := template.ParseFiles(templatePath)
	if err != nil {
		return nil, fmt.Errorf("parse %s: %w", templatePath, err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return nil, fmt.Errorf("execute %s: %w", templatePath, err)
	}
	return buf.Bytes(), nil
}

func resolvePort() int {
	raw := strings.TrimSpace(os.Getenv("PORT"))
	if raw == "" {
		return serverPort
	}

	parsed, err := strconv.Atoi(raw)
	if err != nil || parsed < 1 || parsed > 65535 {
		log.Printf("invalid PORT %q, falling back to %d", raw, serverPort)
		return serverPort
	}
	return parsed
}

func resolvePageData() PageData {
	projectName := strings.TrimSpace(os.Getenv("PROJECT_NAME"))
	if projectName == "" {
		projectName = defaultProjectName
	}

	framework := strings.TrimSpace(os.Getenv("FRAMEWORK"))
	if framework == "" {
		framework = defaultFramework
	}

	return PageData{
		ProjectName: projectName,
		Framework:   framework,
		CLIVersion:  defaultCLIVersion,
	}
}

func main() {
	opts := parseRuntimeOptions()
	bootStart := time.Now()
	templatePath := resolveTemplatePath()
	imagePath := resolveImagePath()
	pageData := resolvePageData()
	welcomeHTML, err := renderHomePage(templatePath, pageData)
	if err != nil {
		log.Fatalf("template initialization failed: %v", err)
	}

	port := resolvePort()

	addr := fmt.Sprintf(":%d", port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatal(err)
	}

{{ if eq .Framework "gin" }}
	gin.SetMode(gin.ReleaseMode)
	app := gin.New()
	app.Use(gin.Recovery())
	routes.RegisterGinRoutes(app, welcomeHTML, imagePath)

	renderStartupBlock("{{ .Framework }}", port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)
	if err := app.RunListener(listener); err != nil {
		log.Fatal(err)
	}
{{ else if eq .Framework "echo" }}
	app := echo.New()
	routes.RegisterEchoRoutes(app, welcomeHTML, imagePath)

	renderStartupBlock("{{ .Framework }}", port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)
	srv := &http.Server{
		Handler:           app,
		ReadHeaderTimeout: 5 * time.Second,
	}
	if err := srv.Serve(listener); err != nil {
		log.Fatal(err)
	}
{{ else if eq .Framework "fiber" }}
	app := fiber.New()
	routes.RegisterFiberRoutes(app, welcomeHTML, imagePath)

	renderStartupBlock("{{ .Framework }}", port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)
	if err := app.Listener(listener); err != nil {
		log.Fatal(err)
	}
{{ else if eq .Framework "nethttp" }}
	mux := routes.RegisterNetHTTPRoutes(welcomeHTML, imagePath)

	renderStartupBlock(pageData.Framework, port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)

	srv := &http.Server{
		Handler:           mux,
		ReadHeaderTimeout: 5 * time.Second,
	}
	if err := srv.Serve(listener); err != nil {
		log.Fatal(err)
	}
{{ end }}
}
