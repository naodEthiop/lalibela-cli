package main

import (
	"flag"
	"fmt"
	"log"
	"net"
	"os/exec"
	"runtime"
	"time"

	"{{ .ModuleName }}/internal/routes"
{{ if eq .Framework "gin" }}
	"github.com/gin-gonic/gin"
{{ else if eq .Framework "echo" }}
	"github.com/labstack/echo/v4"
	"net/http"
{{ else if eq .Framework "fiber" }}
	"github.com/gofiber/fiber/v2"
{{ else if eq .Framework "nethttp" }}
	"html/template"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
{{ end }}
)

const serverPort = 8080

type runtimeOptions struct {
	Open bool
}

func parseRuntimeOptions() runtimeOptions {
	open := flag.Bool("open", false, "Open browser after server starts")
	flag.Parse()
	return runtimeOptions{Open: *open}
}

func openBrowser(targetURL string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "linux":
		cmd = exec.Command("xdg-open", targetURL)
	case "darwin":
		cmd = exec.Command("open", targetURL)
	case "windows":
		cmd = exec.Command("rundll32", "url.dll,FileProtocolHandler", targetURL)
	default:
		return fmt.Errorf("unsupported platform %q", runtime.GOOS)
	}

	if err := cmd.Start(); err != nil {
		return fmt.Errorf("open browser command failed: %w", err)
	}
	return nil
}

func openBrowserIfRequested(open bool, port int) {
	if !open {
		return
	}

	targetURL := fmt.Sprintf("http://localhost:%d", port)
	go func() {
		if err := openBrowser(targetURL); err != nil {
			log.Printf("browser auto-open skipped: %v", err)
		}
	}()
}

{{ if eq .Framework "nethttp" }}
const (
	defaultProjectName = "{{ .ProjectName }}"
	defaultFramework   = "{{ .Framework }}"
)

type PageData struct {
	ProjectName string
	Framework   string
}

var indexTemplate *template.Template

func resolveTemplatePath() string {
	raw := strings.TrimSpace(os.Getenv("INDEX_TEMPLATE_PATH"))
	if raw == "" {
		return filepath.Join("templates", "index.html")
	}
	return raw
}

func resolveImagePath() string {
	raw := strings.TrimSpace(os.Getenv("INDEX_IMAGE_PATH"))
	if raw == "" {
		return filepath.Join("templates", "lalibela2.webp")
	}
	return raw
}

func loadTemplates(templatePath string) error {
	tmpl, err := template.ParseFiles(templatePath)
	if err != nil {
		return fmt.Errorf("parse %s: %w", templatePath, err)
	}
	indexTemplate = tmpl
	return nil
}

func homeHandler(data PageData) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
			return
		}
		if r.URL.Path != "/" {
			http.NotFound(w, r)
			return
		}
		if indexTemplate == nil {
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			return
		}

		w.Header().Set("Content-Type", "text/html; charset=utf-8")
		if err := indexTemplate.Execute(w, data); err != nil {
			log.Printf("rendering index template: %v", err)
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			return
		}
	}
}

func imageHandler(imagePath string) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if r.Method != http.MethodGet {
			http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
			return
		}
		if r.URL.Path != "/lalibela2.webp" {
			http.NotFound(w, r)
			return
		}
		http.ServeFile(w, r, imagePath)
	}
}

func resolvePort() int {
	raw := strings.TrimSpace(os.Getenv("PORT"))
	if raw == "" {
		return serverPort
	}

	parsed, err := strconv.Atoi(raw)
	if err != nil || parsed < 1 || parsed > 65535 {
		log.Printf("invalid PORT %q, falling back to %d", raw, serverPort)
		return serverPort
	}
	return parsed
}

func resolvePageData() PageData {
	projectName := strings.TrimSpace(os.Getenv("PROJECT_NAME"))
	if projectName == "" {
		projectName = defaultProjectName
	}

	framework := strings.TrimSpace(os.Getenv("FRAMEWORK"))
	if framework == "" {
		framework = defaultFramework
	}

	return PageData{
		ProjectName: projectName,
		Framework:   framework,
	}
}
{{ end }}

func main() {
	opts := parseRuntimeOptions()
	bootStart := time.Now()
{{ if eq .Framework "nethttp" }}
	templatePath := resolveTemplatePath()
	imagePath := resolveImagePath()
	if err := loadTemplates(templatePath); err != nil {
		log.Fatalf("template initialization failed: %v", err)
	}

	pageData := resolvePageData()
	port := resolvePort()
{{ else }}
	port := serverPort
{{ end }}

	addr := fmt.Sprintf(":%d", port)
	listener, err := net.Listen("tcp", addr)
	if err != nil {
		log.Fatal(err)
	}

{{ if eq .Framework "gin" }}
	gin.SetMode(gin.ReleaseMode)
	app := gin.New()
	app.Use(gin.Recovery())
	routes.RegisterGinRoutes(app)

	renderStartupBlock("{{ .Framework }}", port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)
	if err := app.RunListener(listener); err != nil {
		log.Fatal(err)
	}
{{ else if eq .Framework "echo" }}
	app := echo.New()
	routes.RegisterEchoRoutes(app)

	renderStartupBlock("{{ .Framework }}", port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)
	srv := &http.Server{
		Handler:           app,
		ReadHeaderTimeout: 5 * time.Second,
	}
	if err := srv.Serve(listener); err != nil {
		log.Fatal(err)
	}
{{ else if eq .Framework "fiber" }}
	app := fiber.New()
	routes.RegisterFiberRoutes(app)

	renderStartupBlock("{{ .Framework }}", port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)
	if err := app.Listener(listener); err != nil {
		log.Fatal(err)
	}
{{ else if eq .Framework "nethttp" }}
	mux := routes.RegisterNetHTTPRoutes()
	mux.HandleFunc("/", homeHandler(pageData))
	mux.HandleFunc("/lalibela2.webp", imageHandler(imagePath))

	renderStartupBlock(pageData.Framework, port, time.Since(bootStart))
	openBrowserIfRequested(opts.Open, port)

	srv := &http.Server{
		Handler:           mux,
		ReadHeaderTimeout: 5 * time.Second,
	}
	if err := srv.Serve(listener); err != nil {
		log.Fatal(err)
	}
{{ end }}
}
